# -*- coding: utf-8 -*-

# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import pytest

import numpy as np
import pandas as pd
import torch

from google.cloud import aiplatform

from tests.system.aiplatform import e2e_base
from tests.system.aiplatform import test_vertex_model


@pytest.mark.usefixtures("prepare_staging_bucket", "delete_staging_bucket", "teardown")
class TestEndToEndVertexModel(e2e_base.TestEndToEnd):
    """End to end system test of the Vertex SDK with the VertexModel interface"""

    _temp_prefix = "ucaip-mb-sasha-dev"

    @pytest.mark.parametrize("training_remote", [True, False])
    @pytest.mark.parametrize("prediction_remote", [True, False])
    def test_end_to_end_vertex_model(
        self, shared_state, training_remote, prediction_remote
    ):
        # Collection of resources generated by this test, to be deleted during teardown
        shared_state["resources"] = []

        aiplatform.init(
            project=e2e_base._PROJECT,
            location=e2e_base._LOCATION,
            staging_bucket="gs://" + shared_state["staging_bucket_name"],
        )

        # Set up random training data
        df = pd.DataFrame(
            np.random.random(size=(100, 3)), columns=["feat_1", "feat_2", "target"]
        )

        # Train using VertexModel interface
        my_model = test_vertex_model.LinearRegression(2, 1)
        my_model.remote = training_remote

        my_model.fit(df, "target", 1, 0.1)

        if training_remote:
            shared_state["resources"].extend([my_model._training_job])
            shared_state["resources"].extend([my_model._model])

        # Set up test data
        data = pd.DataFrame(
            np.random.random(size=(100, 3)), columns=["feat_1", "feat_2", "target"]
        )

        feature_columns = list(data.columns)
        feature_columns.remove("target")

        torch_tensor = torch.tensor(data[feature_columns].values).type(
            torch.FloatTensor
        )

        # Prediction with trained model
        my_model.remote = prediction_remote
        predictions = my_model.predict(torch_tensor)

        if prediction_remote:
            if not training_remote:
                shared_state["resources"].extend([my_model._model])

            shared_state["resources"].extend([my_model._endpoint])

        # Ensure a single prediction was returned
        assert len(predictions) > 0
